{"remainingRequest":"/Users/anne-sophieroy/Downloads/Mainsail/mainsail-maintenance/node_modules/@vue/cli-service/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/anne-sophieroy/Downloads/Mainsail/mainsail-maintenance/src/components/webcams/Mjpegstreamer.vue?vue&type=style&index=0&lang=css&","dependencies":[{"path":"/Users/anne-sophieroy/Downloads/Mainsail/mainsail-maintenance/src/components/webcams/Mjpegstreamer.vue","mtime":1644874918000},{"path":"/Users/anne-sophieroy/Downloads/Mainsail/mainsail-maintenance/node_modules/@vue/cli-service/node_modules/css-loader/dist/cjs.js","mtime":1645990066541},{"path":"/Users/anne-sophieroy/Downloads/Mainsail/mainsail-maintenance/node_modules/@vue/cli-service/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":1645990070825},{"path":"/Users/anne-sophieroy/Downloads/Mainsail/mainsail-maintenance/node_modules/postcss-loader/src/index.js","mtime":1645990067674},{"path":"/Users/anne-sophieroy/Downloads/Mainsail/mainsail-maintenance/node_modules/cache-loader/dist/cjs.js","mtime":1645990064605},{"path":"/Users/anne-sophieroy/Downloads/Mainsail/mainsail-maintenance/node_modules/@vue/cli-service/node_modules/vue-loader/lib/index.js","mtime":1645990069130}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ci53ZWJjYW1JbWFnZSB7CiAgICB3aWR0aDogMTAwJTsKfQoKLndlYmNhbUZwc091dHB1dCB7CiAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7CiAgICBwb3NpdGlvbjphYnNvbHV0ZTsKICAgIGJvdHRvbTogNnB4OwogICAgcmlnaHQ6IDA7CiAgICBiYWNrZ3JvdW5kOiByZ2JhKDAsMCwwLDAuOCk7CiAgICBwYWRkaW5nOiAzcHggMTBweDsKICAgIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDVweDsKfQo="},{"version":3,"sources":["Mjpegstreamer.vue"],"names":[],"mappings":";AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"Mjpegstreamer.vue","sourceRoot":"src/components/webcams","sourcesContent":["<style>\n    .webcamImage {\n        width: 100%;\n    }\n\n    .webcamFpsOutput {\n        display: inline-block;\n        position:absolute;\n        bottom: 6px;\n        right: 0;\n        background: rgba(0,0,0,0.8);\n        padding: 3px 10px;\n        border-top-left-radius: 5px;\n    }\n</style>\n\n<template>\n    <div v-observe-visibility=\"visibilityChanged\" style=\"position: relative;\">\n        <img ref=\"image\" class=\"webcamImage\" :style=\"webcamStyle\" />\n        <span class=\"webcamFpsOutput\" v-if=\"showFps\">{{ $t('Panels.WebcamPanel.FPS')}}: {{ fpsOutput }}</span>\n    </div>\n</template>\n\n<script lang=\"ts\">\nimport Component from 'vue-class-component'\nimport {Mixins, Prop, Watch} from 'vue-property-decorator'\nimport BaseMixin from '@/components/mixins/base'\n\nconst CONTENT_LENGTH = 'content-length'\nconst TYPE_JPEG = 'image/jpeg'\n\n@Component\nexport default class Mjpegstreamer extends Mixins(BaseMixin) {\n    private isVisible = true\n    private currentFPS = 0\n    private timerFPS: number | null = null\n    private timerRestart: number | null = null\n    private stream: ReadableStream | null = null\n    private controller: AbortController | null = null\n\n    @Prop({ required: true })\n    camSettings: any\n\n    @Prop()\n    printerUrl: string | undefined\n\n    @Prop({ default: true }) showFps!: boolean\n\n    $refs!: {\n        canvas: HTMLCanvasElement,\n        image: HTMLImageElement,\n    }\n\n    get url() {\n        const baseUrl = this.camSettings.urlStream\n        const url = new URL(baseUrl, this.printerUrl === undefined ? this.hostUrl.toString() : this.printerUrl)\n\n        return decodeURIComponent(url.toString())\n    }\n\n    get webcamStyle() {\n        let transforms = ''\n        if ('flipX' in this.camSettings && this.camSettings.flipX) transforms += ' scaleX(-1)'\n        if ('flipX' in this.camSettings && this.camSettings.flipY) transforms += ' scaleY(-1)'\n        if (transforms.trimLeft().length) return { transform: transforms.trimLeft() }\n\n        return ''\n    }\n\n    get fpsOutput() {\n        return (this.currentFPS < 10) ? '0'+this.currentFPS.toString() : this.currentFPS\n    }\n\n    startStream() {\n        const SOI = new Uint8Array(2)\n        SOI[0] = 0xFF\n        SOI[1] = 0xD8\n\n        function getLength(headers: any) {\n            let contentLength = -1\n            headers.split('\\n').forEach((header: any) => {\n                const pair = header.split(':')\n                if (pair[0].toLowerCase() === CONTENT_LENGTH) { // Fix for issue https://github.com/aruntj/mjpeg-readable-stream/issues/3 suggested by martapanc\n                    contentLength = pair[1]\n                }\n            })\n            return contentLength\n        }\n\n        this.controller = new AbortController()\n        const { signal } = this.controller\n\n        //readable stream credit to from https://github.com/aruntj/mjpeg-readable-stream\n        fetch(this.url, { signal })\n            .then(response => response.body)\n            .then(rb => {\n                const reader = rb?.getReader()\n\n                let headers = ''\n                let contentLength = -1\n                let imageBuffer: any = null\n                let bytesRead = 0\n                const img = this.$refs.image\n\n                // calculating fps. This is pretty lame. Should probably implement a floating window function.\n                let frames = 0\n\n                this.timerFPS = setInterval(() => {\n                    this.currentFPS = frames\n                    frames = 0\n                }, 1000)\n\n                this.timerRestart = setInterval(() => {\n                    this.restartStream()\n                }, 60000)\n\n                this.stream = new ReadableStream({\n                    start(controller) {\n                        return pump()\n\n                        // The following function handles each data chunk\n                        function pump(): any {\n                            // \"done\" is a Boolean and value a \"Uint8Array\"\n                            return reader?.read().then( ({done, value}) => {\n                                // If there is no more data to read\n                                if (done) {\n                                    window.console.log('done')\n                                    controller.close()\n                                    return\n                                }\n                                // Get the data and send it to the browser via the controller\n                                controller.enqueue(value)\n\n                                if (value) {\n                                    for (let index =0; index < value.length; index++) {\n\n                                        // we've found start of the frame. Everything we've read till now is the header.\n                                        if (value[index] === SOI[0] && value[index+1] === SOI[1]) {\n                                            contentLength = getLength(headers)\n                                            imageBuffer = new Uint8Array(new ArrayBuffer(contentLength))\n                                        }\n                                        // we're still reading the header.\n                                        if (contentLength <= 0) {\n                                            headers += String.fromCharCode(value[index])\n                                        }\n                                        // we're now reading the jpeg.\n                                        else if (bytesRead < contentLength){\n                                            imageBuffer[bytesRead++] = value[index]\n                                        }\n                                        // we're done reading the jpeg. Time to render it.\n                                        else {\n                                            img.src = URL.createObjectURL(new Blob([imageBuffer], {type: TYPE_JPEG}))\n                                            frames++\n                                            contentLength = 0\n                                            bytesRead = 0\n                                            headers = ''\n                                        }\n                                    }\n                                }\n\n                                return pump()\n                            })\n                        }\n                    }\n                })\n            })\n    }\n\n    visibilityChanged(isVisible: boolean) {\n        this.isVisible = isVisible\n\n        if (isVisible) {\n            this.startStream()\n        } else {\n            this.stopStream()\n        }\n    }\n\n    beforeDestroy() {\n        this.stopStream()\n    }\n\n    stopStream() {\n        if (this.timerFPS) clearTimeout(this.timerFPS)\n        if (this.timerRestart) clearTimeout(this.timerRestart)\n        this.controller?.abort()\n        this.stream?.cancel()\n    }\n\n    async restartStream() {\n        this.stopStream()\n        this.startStream()\n    }\n\n    @Watch('url')\n    urlChanged() {\n        this.restartStream()\n    }\n}\n</script>"]}]}