{"remainingRequest":"/Users/anne-sophieroy/Downloads/Mainsail/mainsail-maintenance/node_modules/@vue/cli-service/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/anne-sophieroy/Downloads/Mainsail/mainsail-maintenance/src/components/charts/TempChart.vue?vue&type=script&lang=ts&","dependencies":[{"path":"/Users/anne-sophieroy/Downloads/Mainsail/mainsail-maintenance/src/components/charts/TempChart.vue","mtime":1644874918000},{"path":"/Users/anne-sophieroy/Downloads/Mainsail/mainsail-maintenance/node_modules/cache-loader/dist/cjs.js","mtime":1645990064605},{"path":"/Users/anne-sophieroy/Downloads/Mainsail/mainsail-maintenance/node_modules/babel-loader/lib/index.js","mtime":1645990067759},{"path":"/Users/anne-sophieroy/Downloads/Mainsail/mainsail-maintenance/node_modules/ts-loader/index.js","mtime":1645990068168},{"path":"/Users/anne-sophieroy/Downloads/Mainsail/mainsail-maintenance/node_modules/cache-loader/dist/cjs.js","mtime":1645990064605},{"path":"/Users/anne-sophieroy/Downloads/Mainsail/mainsail-maintenance/node_modules/@vue/cli-service/node_modules/vue-loader/lib/index.js","mtime":1645990069130}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKaW1wb3J0IHsgY29udmVydE5hbWUgfSBmcm9tICdAL3BsdWdpbnMvaGVscGVycycKaW1wb3J0IENvbXBvbmVudCBmcm9tICd2dWUtY2xhc3MtY29tcG9uZW50JwppbXBvcnQge01peGlucywgV2F0Y2h9IGZyb20gJ3Z1ZS1wcm9wZXJ0eS1kZWNvcmF0b3InCmltcG9ydCBCYXNlTWl4aW4gZnJvbSAnLi4vbWl4aW5zL2Jhc2UnCmltcG9ydCB7UHJpbnRlclRlbXBIaXN0b3J5U3RhdGVTZXJpZSwgUHJpbnRlclRlbXBIaXN0b3J5U3RhdGVTb3VyY2VFbnRyeX0gZnJvbSAnQC9zdG9yZS9wcmludGVyL3RlbXBIaXN0b3J5L3R5cGVzJwoKaW1wb3J0IHsgY3JlYXRlQ29tcG9uZW50IH0gZnJvbSAnZWNoYXJ0cy1mb3ItdnVlJwppbXBvcnQgKiBhcyBlY2hhcnRzIGZyb20gJ2VjaGFydHMnCmltcG9ydCB7RUNoYXJ0c30gZnJvbSAnZWNoYXJ0cy9jb3JlJwoKaW50ZXJmYWNlIGVjaGFydHNUb29sdGlwT2JqIHsKICAgIFtrZXk6IHN0cmluZ106IGFueQp9CgpAQ29tcG9uZW50KHsKICAgIGNvbXBvbmVudHM6IHsKICAgICAgICBFQ2hhcnRzOiBjcmVhdGVDb21wb25lbnQoeyBlY2hhcnRzIH0pLAogICAgfQp9KQpleHBvcnQgZGVmYXVsdCBjbGFzcyBUZW1wQ2hhcnQgZXh0ZW5kcyBNaXhpbnMoQmFzZU1peGluKSB7CiAgICBjb252ZXJ0TmFtZSA9IGNvbnZlcnROYW1lCgogICAgJHJlZnMhOiB7CiAgICAgICAgdGVtcGNoYXJ0OiBhbnkKICAgIH0KCiAgICBwcml2YXRlIGlzVmlzaWJsZSA9IHRydWUKICAgIHB1YmxpYyBjaGFydE9wdGlvbnMgPSB7CiAgICAgICAgZGFya01vZGU6IHRydWUsCiAgICAgICAgYW5pbWF0aW9uOiBmYWxzZSwKICAgICAgICB0b29sdGlwOiB7CiAgICAgICAgICAgIGFuaW1hdGlvbjogZmFsc2UsCiAgICAgICAgICAgIHRyaWdnZXI6ICdheGlzJywKICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLDAsMCwwLjkpJywKICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDAsCiAgICAgICAgICAgIHRleHRTdHlsZTogewogICAgICAgICAgICAgICAgY29sb3I6ICcjZmZmJywKICAgICAgICAgICAgICAgIGZvbnRTaXplOiAnMTRweCcKICAgICAgICAgICAgfSwKICAgICAgICAgICAgcGFkZGluZzogMTUsCiAgICAgICAgICAgIGZvcm1hdHRlcjogdGhpcy50b29sdGlwRm9ybWF0ZXIsCiAgICAgICAgICAgIGNvbmZpbmU6IHRydWUsCiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2VjaGFydHMtdG9vbHRpcCcsCiAgICAgICAgICAgIHBvc2l0aW9uOiBmdW5jdGlvbiAocG9zOiBhbnksIHBhcmFtczogYW55LCBkb206IGFueSwgcmVjdDogYW55LCBzaXplOiBhbnkpIHsKICAgICAgICAgICAgICAgIC8vIHRvb2x0aXAgd2lsbCBiZSBmaXhlZCBvbiB0aGUgcmlnaHQgaWYgbW91c2UgaG92ZXJpbmcgb24gdGhlIGxlZnQsCiAgICAgICAgICAgICAgICAvLyBhbmQgb24gdGhlIGxlZnQgaWYgaG92ZXJpbmcgb24gdGhlIHJpZ2h0LgogICAgICAgICAgICAgICAgY29uc3Qgb2JqOiBlY2hhcnRzVG9vbHRpcE9iaiA9IHt0b3A6IDYwfQogICAgICAgICAgICAgICAgb2JqW1snbGVmdCcsICdyaWdodCddWysocG9zWzBdIDwgc2l6ZS52aWV3U2l6ZVswXSAvIDIpXV0gPSA1CiAgICAgICAgICAgICAgICByZXR1cm4gb2JqCiAgICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIGdyaWQ6IHsKICAgICAgICAgICAgdG9wOiAzNSwKICAgICAgICAgICAgcmlnaHQ6IDE1LAogICAgICAgICAgICBib3R0b206IDMwLAogICAgICAgICAgICBsZWZ0OiAyNSwKICAgICAgICB9LAogICAgICAgIGxlZ2VuZDogewogICAgICAgICAgICBhbmltYXRpb246IGZhbHNlLAogICAgICAgICAgICBzaG93OiBmYWxzZSwKICAgICAgICAgICAgc2VsZWN0ZWQ6IHt9CiAgICAgICAgfSwKICAgICAgICAvKmRhdGFab29tOiBbewogICAgICAgICAgICB0eXBlOiAnaW5zaWRlJywKICAgICAgICB9XSwqLwogICAgICAgIHhBeGlzOiB7CiAgICAgICAgICAgIHR5cGU6ICd0aW1lJywKICAgICAgICAgICAgc3BsaXROdW1iZXI6IDUsCiAgICAgICAgICAgIG1pbkludGVydmFsOiA2MCoxMDAwLAogICAgICAgICAgICBzcGxpdExpbmU6IHsKICAgICAgICAgICAgICAgIHNob3c6IHRydWUsCiAgICAgICAgICAgICAgICBsaW5lU3R5bGU6IHsKICAgICAgICAgICAgICAgICAgICBjb2xvcjogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC4wNiknLAogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgfSwKICAgICAgICAgICAgYXhpc0xhYmVsOiB7CiAgICAgICAgICAgICAgICBjb2xvcjogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC4yNCknLAogICAgICAgICAgICAgICAgbWFyZ2luOiAxMCwKICAgICAgICAgICAgfSwKICAgICAgICB9LAogICAgICAgIHlBeGlzOiBbCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMuJHQoJ1BhbmVscy5Ub29sc1BhbmVsLlRlbXBlcmF0dXJlc0luQ2hhcnQnKSwKICAgICAgICAgICAgICAgIHR5cGU6ICd2YWx1ZScsCiAgICAgICAgICAgICAgICBtaW46IDAsCiAgICAgICAgICAgICAgICBtYXg6ICh2YWx1ZTogYW55KSA9PiB7CiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmF1dG9zY2FsZSkgcmV0dXJuIHRoaXMubWF4VGVtcAoKICAgICAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5jZWlsKCh2YWx1ZS5tYXggKyA1KSAvIDIwKSAqIDIwCiAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgbWluSW50ZXJ2YWw6IDIwLAogICAgICAgICAgICAgICAgbWF4SW50ZXJ2YWw6IDEwMCwKICAgICAgICAgICAgICAgIG5hbWVMb2NhdGlvbjogJ2VuZCcsCiAgICAgICAgICAgICAgICBuYW1lR2FwOiA1LAogICAgICAgICAgICAgICAgbmFtZVRleHRTdHlsZTogewogICAgICAgICAgICAgICAgICAgIGNvbG9yOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjI0KScsCiAgICAgICAgICAgICAgICAgICAgYWxpZ246ICdsZWZ0JywKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICBzcGxpdExpbmU6IHsKICAgICAgICAgICAgICAgICAgICBsaW5lU3R5bGU6IHsKICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMTIpJywKICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgIGF4aXNMYWJlbDogewogICAgICAgICAgICAgICAgICAgIGNvbG9yOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjI0KScsCiAgICAgICAgICAgICAgICAgICAgZm9ybWF0dGVyOiAne3ZhbHVlfScsCiAgICAgICAgICAgICAgICAgICAgcm90YXRlOiA5MCwKICAgICAgICAgICAgICAgICAgICAvL3Nob3dNYXhMYWJlbDogZmFsc2UsCiAgICAgICAgICAgICAgICAgICAgc2hvd01pbkxhYmVsOiB0cnVlLAogICAgICAgICAgICAgICAgICAgIG1hcmdpbjogNSwKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICBheGlzTGluZTogewogICAgICAgICAgICAgICAgICAgIHNob3c6IHRydWUsCiAgICAgICAgICAgICAgICAgICAgbGluZVN0eWxlOiB7CiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjEyKScsCiAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgIH0sIHsKICAgICAgICAgICAgICAgIHNob3c6IHRoaXMuYm9vbERpc3BsYXlQd21BeGlzLAogICAgICAgICAgICAgICAgbmFtZTogJ1BXTSBbJV0nLAogICAgICAgICAgICAgICAgbWluOiAwLAogICAgICAgICAgICAgICAgbWF4OiAxLAogICAgICAgICAgICAgICAgbWluSW50ZXJ2YWw6IDAuMjUsCiAgICAgICAgICAgICAgICB0eXBlOiAndmFsdWUnLAogICAgICAgICAgICAgICAgbmFtZUxvY2F0aW9uOiAnZW5kJywKICAgICAgICAgICAgICAgIG5hbWVHYXA6IDUsCiAgICAgICAgICAgICAgICBuYW1lVGV4dFN0eWxlOiB7CiAgICAgICAgICAgICAgICAgICAgY29sb3I6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMjQpJywKICAgICAgICAgICAgICAgICAgICBhbGlnbjogJ3JpZ2h0JywKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICBzcGxpdExpbmU6IHsKICAgICAgICAgICAgICAgICAgICBzaG93OiBmYWxzZSwKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICBheGlzTGFiZWw6IHsKICAgICAgICAgICAgICAgICAgICBjb2xvcjogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC4yNCknLAogICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlcjogKHZhbHVlOiBudW1iZXIpID0+IHsgcmV0dXJuIHZhbHVlICogMTAwIH0sCiAgICAgICAgICAgICAgICAgICAgc2hvd01pbkxhYmVsOiB0cnVlLAogICAgICAgICAgICAgICAgICAgIHJvdGF0ZTogOTAsCiAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiA1LAogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgIGF4aXNMaW5lOiB7CiAgICAgICAgICAgICAgICAgICAgc2hvdzogdHJ1ZSwKICAgICAgICAgICAgICAgICAgICBsaW5lU3R5bGU6IHsKICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMTIpJywKICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgXSwKICAgICAgICBtZWRpYTogW3sKICAgICAgICAgICAgcXVlcnk6IHsKICAgICAgICAgICAgICAgIG1pbldpZHRoOiA1MDAsCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIG9wdGlvbjogewogICAgICAgICAgICAgICAgZ3JpZDogewogICAgICAgICAgICAgICAgICAgIHJpZ2h0OiAxNSwKICAgICAgICAgICAgICAgICAgICBsZWZ0OiA0MCwKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICB5QXhpczogWwogICAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICAgICAgbWF4SW50ZXJ2YWw6IDUwLAogICAgICAgICAgICAgICAgICAgICAgICBheGlzTGFiZWw6IHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3dNaW5MYWJlbDogZmFsc2UsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG93TWF4TGFiZWw6IHRydWUsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3RhdGU6IDAKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICBtYXhJbnRlcnZhbDogMjUsCiAgICAgICAgICAgICAgICAgICAgICAgIGF4aXNMYWJlbDogewogICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvd01pbkxhYmVsOiBmYWxzZSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdGF0ZTogMAogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgIF0sCiAgICAgICAgICAgIH0KICAgICAgICB9XSwKICAgICAgICBkYXRhc2V0OiB7CiAgICAgICAgICAgIHNvdXJjZTogW10KICAgICAgICB9LAogICAgICAgIHNlcmllczogW10KICAgIH0KCiAgICBnZXQgY2hhcnQgKCk6IEVDaGFydHMgfCBudWxsIHsKICAgICAgICBjb25zdCB0ZW1wY2hhcnQgPSB0aGlzLiRyZWZzLnRlbXBjaGFydAogICAgICAgIHJldHVybiB0ZW1wY2hhcnQ/Lmluc3QgPz8gbnVsbAogICAgfQoKICAgIGdldCBtYXhIaXN0b3J5KCkgewogICAgICAgIHJldHVybiB0aGlzLiRzdG9yZS5nZXR0ZXJzWydzZXJ2ZXIvZ2V0Q29uZmlnJ10oJ3NlcnZlcicsICd0ZW1wZXJhdHVyZV9zdG9yZV9zaXplJykgPz8gMTIwMAogICAgfQoKICAgIGdldCBzZXJpZXMoKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuJHN0b3JlLnN0YXRlLnByaW50ZXIudGVtcEhpc3Rvcnkuc2VyaWVzID8/IHt9CiAgICB9CgogICAgZ2V0IHNvdXJjZSgpIHsKICAgICAgICByZXR1cm4gdGhpcy4kc3RvcmUuc3RhdGUucHJpbnRlci50ZW1wSGlzdG9yeS5zb3VyY2UgPz8gW10KICAgIH0KCiAgICBnZXQgYXV0b3NjYWxlKCkgewogICAgICAgIHJldHVybiB0aGlzLiRzdG9yZS5zdGF0ZS5ndWkudmlldy50ZW1wY2hhcnQuYXV0b3NjYWxlID8/IHRydWUKICAgIH0KCiAgICBnZXQgbWF4VGVtcCgpIHsKICAgICAgICByZXR1cm4gdGhpcy4kc3RvcmUuZ2V0dGVyc1sncHJpbnRlci9nZXRNYXhUZW1wJ10gPz8gMzAwCiAgICB9CgogICAgZ2V0IGJvb2xEaXNwbGF5UHdtQXhpcygpIHsKICAgICAgICByZXR1cm4gdGhpcy4kc3RvcmUuZ2V0dGVyc1sncHJpbnRlci90ZW1wSGlzdG9yeS9nZXRCb29sRGlzcGxheVB3bUF4aXMnXQogICAgfQoKICAgIGdldCBzZWxlY3RlZExlZ2VuZHMoKSB7CiAgICAgICAgcmV0dXJuIHRoaXMuJHN0b3JlLmdldHRlcnNbJ3ByaW50ZXIvdGVtcEhpc3RvcnkvZ2V0U2VsZWN0ZWRMZWdlbmRzJ10KICAgIH0KCiAgICBtb3VudGVkKCkgewogICAgICAgIHRoaXMuaW5pdENoYXJ0KCkKICAgIH0KCiAgICBiZWZvcmVEZXN0cm95KCkgewogICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuCiAgICAgICAgaWYgKHRoaXMuY2hhcnQpIHRoaXMuY2hhcnQuZGlzcG9zZSgpCiAgICB9CgogICAgaW5pdENoYXJ0KCkgewogICAgICAgIHRoaXMuY2hhcnRPcHRpb25zLnNlcmllcyA9IHRoaXMuc2VyaWVzCiAgICAgICAgdGhpcy5jaGFydE9wdGlvbnMubGVnZW5kLnNlbGVjdGVkID0gdGhpcy5zZWxlY3RlZExlZ2VuZHMKICAgICAgICB0aGlzLnVwZGF0ZUNoYXJ0UHdtQXhpcygpCiAgICB9CgogICAgdXBkYXRlQ2hhcnQoKSB7CiAgICAgICAgaWYgKHRoaXMuY2hhcnQgJiYgdGhpcy5pc1Zpc2libGUpIHsKICAgICAgICAgICAgLy9jb25zdCB0MCA9IHBlcmZvcm1hbmNlLm5vdygpCiAgICAgICAgICAgIGNvbnN0IGxpbWl0RGF0ZSA9IG5ldyBEYXRlKERhdGUubm93KCkgLSB0aGlzLm1heEhpc3RvcnkgKiAxMDAwKQogICAgICAgICAgICBsZXQgbmV3U291cmNlID0gWy4uLnRoaXMuc291cmNlXS5maWx0ZXIoKGVudHJ5OiBQcmludGVyVGVtcEhpc3RvcnlTdGF0ZVNvdXJjZUVudHJ5KSA9PiB7CiAgICAgICAgICAgICAgICByZXR1cm4gZW50cnkuZGF0ZSA+PSBsaW1pdERhdGUKICAgICAgICAgICAgfSkKCiAgICAgICAgICAgIHRoaXMuY2hhcnQ/LnNldE9wdGlvbih7CiAgICAgICAgICAgICAgICBkYXRhc2V0OiB7CiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBuZXdTb3VyY2UKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgIH0pCgogICAgICAgICAgICAvL2NvbnN0IHQxID0gcGVyZm9ybWFuY2Uubm93KCkKICAgICAgICAgICAgLy93aW5kb3cuY29uc29sZS5kZWJ1ZygnY2FsYyBjaGFydCcsICh0MS10MCkudG9GaXhlZCgpLCBuZXdTb3VyY2UubGVuZ3RoLCB0aGlzLnNvdXJjZS5sZW5ndGgpCgogICAgICAgICAgICAvLyByZXNldCB0ZW1wSGlzdG9yeSBpZiB3b3JraW5nIHNvdXJjZXMgYXJlIHNtYWxsZXIgdGhhbiA4MCUKICAgICAgICAgICAgaWYgKHRoaXMuc291cmNlLmxlbmd0aCA+IDAgJiYgbmV3U291cmNlLmxlbmd0aCA8IHRoaXMubWF4SGlzdG9yeSAqIDAuOCkgewogICAgICAgICAgICAgICAgdGhpcy4kc29ja2V0LmVtaXQoJ3NlcnZlci50ZW1wZXJhdHVyZV9zdG9yZScsIHt9LCB7IGFjdGlvbjogJ3ByaW50ZXIvdGVtcEhpc3RvcnkvaW5pdCcgfSkKICAgICAgICAgICAgfQogICAgICAgIH0KICAgIH0KCiAgICB1cGRhdGVDaGFydFB3bUF4aXMoKSB7CiAgICAgICAgaWYgKHRoaXMuYm9vbERpc3BsYXlQd21BeGlzKSB7CiAgICAgICAgICAgIHRoaXMuY2hhcnRPcHRpb25zLnlBeGlzWzFdLnNob3cgPSB0cnVlCiAgICAgICAgICAgIHRoaXMuY2hhcnRPcHRpb25zLmdyaWQucmlnaHQgPSAyNQogICAgICAgICAgICB0aGlzLmNoYXJ0T3B0aW9ucy5tZWRpYVswXS5vcHRpb24uZ3JpZC5yaWdodCA9IDM1CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdGhpcy5jaGFydE9wdGlvbnMueUF4aXNbMV0uc2hvdyA9IGZhbHNlCiAgICAgICAgICAgIHRoaXMuY2hhcnRPcHRpb25zLmdyaWQucmlnaHQgPSAxNQogICAgICAgICAgICB0aGlzLmNoYXJ0T3B0aW9ucy5tZWRpYVswXS5vcHRpb24uZ3JpZC5yaWdodCA9IDE1CiAgICAgICAgfQogICAgfQoKICAgIHZpc2liaWxpdHlDaGFuZ2VkIChpc1Zpc2libGU6IGJvb2xlYW4pIHsKICAgICAgICB0aGlzLmlzVmlzaWJsZSA9IGlzVmlzaWJsZQoKICAgICAgICBpZiAoaXNWaXNpYmxlKSB7CiAgICAgICAgICAgIHRoaXMuaW5pdENoYXJ0KCkKICAgICAgICB9CiAgICB9CgogICAgdG9vbHRpcEZvcm1hdGVyKGRhdGFzZXRzOiBhbnkpIHsKICAgICAgICBsZXQgb3V0cHV0ID0gJycKCiAgICAgICAgY29uc3QgbWFpbkRhdGFzZXRzID0gZGF0YXNldHMuZmlsdGVyKChkYXRhc2V0OiBhbnkpID0+IHsKICAgICAgICAgICAgaWYgKGRhdGFzZXQuc2VyaWVzTmFtZSA9PT0gJ2RhdGUnKSByZXR1cm4gZmFsc2UKICAgICAgICAgICAgaWYgKGRhdGFzZXQuc2VyaWVzTmFtZS5pbmNsdWRlcygnLScpKSB7CiAgICAgICAgICAgICAgICBpZiAoZGF0YXNldC5zZXJpZXNOYW1lLmxhc3RJbmRleE9mKCctJykgPiAtMSkgewogICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1ZmZpeCA9IGRhdGFzZXQuc2VyaWVzTmFtZS5zbGljZShkYXRhc2V0LnNlcmllc05hbWUubGFzdEluZGV4T2YoJy0nKSArIDEpCiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFbJ3RhcmdldCcsICdwb3dlciddLmluY2x1ZGVzKHN1ZmZpeCkKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZQogICAgICAgICAgICB9CgogICAgICAgICAgICByZXR1cm4gdHJ1ZQogICAgICAgIH0pCiAgICAgICAgaWYgKGRhdGFzZXRzLmxlbmd0aCkgewogICAgICAgICAgICBsZXQgb3V0cHV0VGltZSA9IGRhdGFzZXRzWzBdWydheGlzVmFsdWVMYWJlbCddCiAgICAgICAgICAgIG91dHB1dFRpbWUgPSBvdXRwdXRUaW1lLnN1YnN0cihvdXRwdXRUaW1lLmluZGV4T2YoJyAnKSkKCiAgICAgICAgICAgIG91dHB1dCArPQogICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9InJvdyI+JyArCiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz0iY29sIHB5LTEiIHN0eWxlPVwnYm9yZGVyLWJvdHRvbTogMXB4IHNvbGlkIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4yNCk7XCc+JyArCiAgICAgICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCd2LWljb24gbWRpIG1kaS1jbG9jayB0aGVtZS1kYXJrXCcgc3R5bGU9XCdmb250LXNpemU6IDE0cHg7IG1hcmdpbi1yaWdodDogNXB4O1wnPjwvc3Bhbj4nICsKICAgICAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cJ2ZvbnQtd2VpZ2h0LWJvbGRcJz4nK291dHB1dFRpbWUrJzwvc3Bhbj4nICsKICAgICAgICAgICAgICAgICc8L2Rpdj4nICsKICAgICAgICAgICAgICAgICc8L2Rpdj4nCiAgICAgICAgfQoKICAgICAgICBtYWluRGF0YXNldHMuZm9yRWFjaCgoZGF0YXNldDogYW55KSA9PiB7CiAgICAgICAgICAgIG91dHB1dCArPSAnPGRpdiBjbGFzcz0icm93Ij4nCgogICAgICAgICAgICBvdXRwdXQgKz0gJzxkaXYgY2xhc3M9ImNvbC1hdXRvIHB5LTAiPicKICAgICAgICAgICAgb3V0cHV0ICs9IGRhdGFzZXQubWFya2VyCiAgICAgICAgICAgIG91dHB1dCArPSAnPHNwYW4gY2xhc3M9XCdtbC0yXCc+Jytjb252ZXJ0TmFtZShkYXRhc2V0LnNlcmllc05hbWUpKyc6PC9zcGFuPicKICAgICAgICAgICAgb3V0cHV0ICs9ICc8L2Rpdj4nCgogICAgICAgICAgICBvdXRwdXQgKz0gJzxkaXYgY2xhc3M9ImNvbCB0ZXh0LXJpZ2h0IHB5LTAgZm9udC13ZWlnaHQtYm9sZCI+JwoKICAgICAgICAgICAgaWYgKGRhdGFzZXQuc2VyaWVzTmFtZSBpbiBkYXRhc2V0LnZhbHVlKSBvdXRwdXQgKz0gZGF0YXNldC52YWx1ZVtkYXRhc2V0LnNlcmllc05hbWVdLnRvRml4ZWQoMSkKICAgICAgICAgICAgaWYgKGRhdGFzZXQuc2VyaWVzTmFtZSsnLXRhcmdldCcgaW4gZGF0YXNldC52YWx1ZSkgb3V0cHV0ICs9ICcgLyAnK2RhdGFzZXQudmFsdWVbZGF0YXNldC5zZXJpZXNOYW1lKyctdGFyZ2V0J10udG9GaXhlZCgxKQogICAgICAgICAgICBvdXRwdXQgKz0gJ8KwQycKCiAgICAgICAgICAgIGlmIChkYXRhc2V0LnNlcmllc05hbWUrJy1wb3dlcicgaW4gZGF0YXNldC52YWx1ZSkgb3V0cHV0ICs9ICcgWyAnKyhkYXRhc2V0LnZhbHVlW2RhdGFzZXQuc2VyaWVzTmFtZSsnLXBvd2VyJ10qMTAwKS50b0ZpeGVkKDApKyclIF0nCiAgICAgICAgICAgIGlmIChkYXRhc2V0LnNlcmllc05hbWUrJy1zcGVlZCcgaW4gZGF0YXNldC52YWx1ZSkgb3V0cHV0ICs9ICcgWyAnKyhkYXRhc2V0LnZhbHVlW2RhdGFzZXQuc2VyaWVzTmFtZSsnLXNwZWVkJ10qMTAwKS50b0ZpeGVkKDApKyclIF0nCgogICAgICAgICAgICBvdXRwdXQgKz0gJzwvZGl2PicKICAgICAgICAgICAgb3V0cHV0ICs9ICc8L2Rpdj4nCiAgICAgICAgfSkKCiAgICAgICAgcmV0dXJuIG91dHB1dAogICAgfQoKICAgIEBXYXRjaCgnc2VyaWVzJywgeyBkZWVwOiB0cnVlIH0pCiAgICBzZXJpZXNDaGFuZ2VkKG5ld1ZhbDogUHJpbnRlclRlbXBIaXN0b3J5U3RhdGVTZXJpZVtdKSB7CiAgICAgICAgaWYgKHRoaXMuY2hhcnQgJiYgdGhpcy5jaGFydD8uaXNEaXNwb3NlZCgpICE9PSB0cnVlKSB7CiAgICAgICAgICAgIHRoaXMuY2hhcnQuc2V0T3B0aW9uKHsKICAgICAgICAgICAgICAgIHNlcmllczogbmV3VmFsCiAgICAgICAgICAgIH0pCiAgICAgICAgfQogICAgfQoKICAgIEBXYXRjaCgnc291cmNlJykKICAgIHNvdXJjZUNoYW5nZWQoKSB7CiAgICAgICAgaWYgKHRoaXMuY2hhcnQ/LmlzRGlzcG9zZWQoKSAhPT0gdHJ1ZSkgewogICAgICAgICAgICB0aGlzLnVwZGF0ZUNoYXJ0KCkKICAgICAgICB9CiAgICB9CgogICAgQFdhdGNoKCdzZWxlY3RlZExlZ2VuZHMnKQogICAgc2VsZWN0ZWRMZWdlbmRzQ2hhbmdlZChuZXdWYWw6IGFueSwgb2xkVmFsOmFueSkgewogICAgICAgIGlmICh0aGlzLmNoYXJ0Py5pc0Rpc3Bvc2VkKCkgIT09IHRydWUpIHsKICAgICAgICAgICAgT2JqZWN0LmtleXMobmV3VmFsKS5mb3JFYWNoKChrZXkpID0+IHsKICAgICAgICAgICAgICAgIGlmIChuZXdWYWxba2V5XSAhPT0gb2xkVmFsW2tleV0pIHsKICAgICAgICAgICAgICAgICAgICBjb25zdCBhY3Rpb25UeXBlID0gbmV3VmFsW2tleV0gPyAnbGVnZW5kU2VsZWN0JyA6ICdsZWdlbmRVblNlbGVjdCcKICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYXJ0Py5kaXNwYXRjaEFjdGlvbih7IHR5cGU6IGFjdGlvblR5cGUsIG5hbWU6IGtleSB9KQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9KQogICAgICAgIH0KICAgIH0KCiAgICBAV2F0Y2goJ2Jvb2xEaXNwbGF5UHdtQXhpcycpCiAgICBib29sRGlzcGxheVB3bUF4aXNDaGFuZ2VkKCkgewogICAgICAgIHRoaXMudXBkYXRlQ2hhcnRQd21BeGlzKCkKICAgIH0KfQo="},{"version":3,"sources":["TempChart.vue"],"names":[],"mappings":";;;;;;;;;;;;AAYA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA","file":"TempChart.vue","sourceRoot":"src/components/charts","sourcesContent":["<template>\n    <ECharts\n        ref=\"tempchart\"\n        :option=\"chartOptions\"\n        :init-options=\"{ renderer: 'svg' }\"\n        style=\"height: 250px; width: 100%;\"\n        v-observe-visibility=\"visibilityChanged\"\n    ></ECharts>\n</template>\n\n<script lang=\"ts\">\n\nimport { convertName } from '@/plugins/helpers'\nimport Component from 'vue-class-component'\nimport {Mixins, Watch} from 'vue-property-decorator'\nimport BaseMixin from '../mixins/base'\nimport {PrinterTempHistoryStateSerie, PrinterTempHistoryStateSourceEntry} from '@/store/printer/tempHistory/types'\n\nimport { createComponent } from 'echarts-for-vue'\nimport * as echarts from 'echarts'\nimport {ECharts} from 'echarts/core'\n\ninterface echartsTooltipObj {\n    [key: string]: any\n}\n\n@Component({\n    components: {\n        ECharts: createComponent({ echarts }),\n    }\n})\nexport default class TempChart extends Mixins(BaseMixin) {\n    convertName = convertName\n\n    $refs!: {\n        tempchart: any\n    }\n\n    private isVisible = true\n    public chartOptions = {\n        darkMode: true,\n        animation: false,\n        tooltip: {\n            animation: false,\n            trigger: 'axis',\n            backgroundColor: 'rgba(0,0,0,0.9)',\n            borderWidth: 0,\n            textStyle: {\n                color: '#fff',\n                fontSize: '14px'\n            },\n            padding: 15,\n            formatter: this.tooltipFormater,\n            confine: true,\n            className: 'echarts-tooltip',\n            position: function (pos: any, params: any, dom: any, rect: any, size: any) {\n                // tooltip will be fixed on the right if mouse hovering on the left,\n                // and on the left if hovering on the right.\n                const obj: echartsTooltipObj = {top: 60}\n                obj[['left', 'right'][+(pos[0] < size.viewSize[0] / 2)]] = 5\n                return obj\n            }\n        },\n        grid: {\n            top: 35,\n            right: 15,\n            bottom: 30,\n            left: 25,\n        },\n        legend: {\n            animation: false,\n            show: false,\n            selected: {}\n        },\n        /*dataZoom: [{\n            type: 'inside',\n        }],*/\n        xAxis: {\n            type: 'time',\n            splitNumber: 5,\n            minInterval: 60*1000,\n            splitLine: {\n                show: true,\n                lineStyle: {\n                    color: 'rgba(255, 255, 255, 0.06)',\n                },\n            },\n            axisLabel: {\n                color: 'rgba(255, 255, 255, 0.24)',\n                margin: 10,\n            },\n        },\n        yAxis: [\n            {\n                name: this.$t('Panels.ToolsPanel.TemperaturesInChart'),\n                type: 'value',\n                min: 0,\n                max: (value: any) => {\n                    if (!this.autoscale) return this.maxTemp\n\n                    return Math.ceil((value.max + 5) / 20) * 20\n                },\n                minInterval: 20,\n                maxInterval: 100,\n                nameLocation: 'end',\n                nameGap: 5,\n                nameTextStyle: {\n                    color: 'rgba(255, 255, 255, 0.24)',\n                    align: 'left',\n                },\n                splitLine: {\n                    lineStyle: {\n                        color: 'rgba(255, 255, 255, 0.12)',\n                    },\n                },\n                axisLabel: {\n                    color: 'rgba(255, 255, 255, 0.24)',\n                    formatter: '{value}',\n                    rotate: 90,\n                    //showMaxLabel: false,\n                    showMinLabel: true,\n                    margin: 5,\n                },\n                axisLine: {\n                    show: true,\n                    lineStyle: {\n                        color: 'rgba(255, 255, 255, 0.12)',\n                    },\n                },\n            }, {\n                show: this.boolDisplayPwmAxis,\n                name: 'PWM [%]',\n                min: 0,\n                max: 1,\n                minInterval: 0.25,\n                type: 'value',\n                nameLocation: 'end',\n                nameGap: 5,\n                nameTextStyle: {\n                    color: 'rgba(255, 255, 255, 0.24)',\n                    align: 'right',\n                },\n                splitLine: {\n                    show: false,\n                },\n                axisLabel: {\n                    color: 'rgba(255, 255, 255, 0.24)',\n                    formatter: (value: number) => { return value * 100 },\n                    showMinLabel: true,\n                    rotate: 90,\n                    margin: 5,\n                },\n                axisLine: {\n                    show: true,\n                    lineStyle: {\n                        color: 'rgba(255, 255, 255, 0.12)',\n                    },\n                }\n            }\n        ],\n        media: [{\n            query: {\n                minWidth: 500,\n            },\n            option: {\n                grid: {\n                    right: 15,\n                    left: 40,\n                },\n                yAxis: [\n                    {\n                        maxInterval: 50,\n                        axisLabel: {\n                            showMinLabel: false,\n                            showMaxLabel: true,\n                            rotate: 0\n                        }\n                    },\n                    {\n                        maxInterval: 25,\n                        axisLabel: {\n                            showMinLabel: false,\n                            rotate: 0\n                        }\n                    },\n                ],\n            }\n        }],\n        dataset: {\n            source: []\n        },\n        series: []\n    }\n\n    get chart (): ECharts | null {\n        const tempchart = this.$refs.tempchart\n        return tempchart?.inst ?? null\n    }\n\n    get maxHistory() {\n        return this.$store.getters['server/getConfig']('server', 'temperature_store_size') ?? 1200\n    }\n\n    get series() {\n        return this.$store.state.printer.tempHistory.series ?? {}\n    }\n\n    get source() {\n        return this.$store.state.printer.tempHistory.source ?? []\n    }\n\n    get autoscale() {\n        return this.$store.state.gui.view.tempchart.autoscale ?? true\n    }\n\n    get maxTemp() {\n        return this.$store.getters['printer/getMaxTemp'] ?? 300\n    }\n\n    get boolDisplayPwmAxis() {\n        return this.$store.getters['printer/tempHistory/getBoolDisplayPwmAxis']\n    }\n\n    get selectedLegends() {\n        return this.$store.getters['printer/tempHistory/getSelectedLegends']\n    }\n\n    mounted() {\n        this.initChart()\n    }\n\n    beforeDestroy() {\n        if (typeof window === 'undefined') return\n        if (this.chart) this.chart.dispose()\n    }\n\n    initChart() {\n        this.chartOptions.series = this.series\n        this.chartOptions.legend.selected = this.selectedLegends\n        this.updateChartPwmAxis()\n    }\n\n    updateChart() {\n        if (this.chart && this.isVisible) {\n            //const t0 = performance.now()\n            const limitDate = new Date(Date.now() - this.maxHistory * 1000)\n            let newSource = [...this.source].filter((entry: PrinterTempHistoryStateSourceEntry) => {\n                return entry.date >= limitDate\n            })\n\n            this.chart?.setOption({\n                dataset: {\n                    source: newSource\n                },\n            })\n\n            //const t1 = performance.now()\n            //window.console.debug('calc chart', (t1-t0).toFixed(), newSource.length, this.source.length)\n\n            // reset tempHistory if working sources are smaller than 80%\n            if (this.source.length > 0 && newSource.length < this.maxHistory * 0.8) {\n                this.$socket.emit('server.temperature_store', {}, { action: 'printer/tempHistory/init' })\n            }\n        }\n    }\n\n    updateChartPwmAxis() {\n        if (this.boolDisplayPwmAxis) {\n            this.chartOptions.yAxis[1].show = true\n            this.chartOptions.grid.right = 25\n            this.chartOptions.media[0].option.grid.right = 35\n        } else {\n            this.chartOptions.yAxis[1].show = false\n            this.chartOptions.grid.right = 15\n            this.chartOptions.media[0].option.grid.right = 15\n        }\n    }\n\n    visibilityChanged (isVisible: boolean) {\n        this.isVisible = isVisible\n\n        if (isVisible) {\n            this.initChart()\n        }\n    }\n\n    tooltipFormater(datasets: any) {\n        let output = ''\n\n        const mainDatasets = datasets.filter((dataset: any) => {\n            if (dataset.seriesName === 'date') return false\n            if (dataset.seriesName.includes('-')) {\n                if (dataset.seriesName.lastIndexOf('-') > -1) {\n                    const suffix = dataset.seriesName.slice(dataset.seriesName.lastIndexOf('-') + 1)\n                    return !['target', 'power'].includes(suffix)\n                }\n\n                return true\n            }\n\n            return true\n        })\n        if (datasets.length) {\n            let outputTime = datasets[0]['axisValueLabel']\n            outputTime = outputTime.substr(outputTime.indexOf(' '))\n\n            output +=\n                '<div class=\"row\">' +\n                '<div class=\"col py-1\" style=\\'border-bottom: 1px solid rgba(255, 255, 255, 0.24);\\'>' +\n                '<span class=\\'v-icon mdi mdi-clock theme-dark\\' style=\\'font-size: 14px; margin-right: 5px;\\'></span>' +\n                '<span class=\\'font-weight-bold\\'>'+outputTime+'</span>' +\n                '</div>' +\n                '</div>'\n        }\n\n        mainDatasets.forEach((dataset: any) => {\n            output += '<div class=\"row\">'\n\n            output += '<div class=\"col-auto py-0\">'\n            output += dataset.marker\n            output += '<span class=\\'ml-2\\'>'+convertName(dataset.seriesName)+':</span>'\n            output += '</div>'\n\n            output += '<div class=\"col text-right py-0 font-weight-bold\">'\n\n            if (dataset.seriesName in dataset.value) output += dataset.value[dataset.seriesName].toFixed(1)\n            if (dataset.seriesName+'-target' in dataset.value) output += ' / '+dataset.value[dataset.seriesName+'-target'].toFixed(1)\n            output += '°C'\n\n            if (dataset.seriesName+'-power' in dataset.value) output += ' [ '+(dataset.value[dataset.seriesName+'-power']*100).toFixed(0)+'% ]'\n            if (dataset.seriesName+'-speed' in dataset.value) output += ' [ '+(dataset.value[dataset.seriesName+'-speed']*100).toFixed(0)+'% ]'\n\n            output += '</div>'\n            output += '</div>'\n        })\n\n        return output\n    }\n\n    @Watch('series', { deep: true })\n    seriesChanged(newVal: PrinterTempHistoryStateSerie[]) {\n        if (this.chart && this.chart?.isDisposed() !== true) {\n            this.chart.setOption({\n                series: newVal\n            })\n        }\n    }\n\n    @Watch('source')\n    sourceChanged() {\n        if (this.chart?.isDisposed() !== true) {\n            this.updateChart()\n        }\n    }\n\n    @Watch('selectedLegends')\n    selectedLegendsChanged(newVal: any, oldVal:any) {\n        if (this.chart?.isDisposed() !== true) {\n            Object.keys(newVal).forEach((key) => {\n                if (newVal[key] !== oldVal[key]) {\n                    const actionType = newVal[key] ? 'legendSelect' : 'legendUnSelect'\n                    this.chart?.dispatchAction({ type: actionType, name: key })\n                }\n            })\n        }\n    }\n\n    @Watch('boolDisplayPwmAxis')\n    boolDisplayPwmAxisChanged() {\n        this.updateChartPwmAxis()\n    }\n}\n</script>"]}]}