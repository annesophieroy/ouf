{"remainingRequest":"/Users/anne-sophieroy/Downloads/Mainsail/mainsail-maintenance/node_modules/@vue/cli-service/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/anne-sophieroy/Downloads/Mainsail/mainsail-maintenance/src/components/webcams/MjpegstreamerAdaptive.vue?vue&type=style&index=0&id=0aa63aa1&scoped=true&lang=css&","dependencies":[{"path":"/Users/anne-sophieroy/Downloads/Mainsail/mainsail-maintenance/src/components/webcams/MjpegstreamerAdaptive.vue","mtime":1644874918000},{"path":"/Users/anne-sophieroy/Downloads/Mainsail/mainsail-maintenance/node_modules/@vue/cli-service/node_modules/css-loader/dist/cjs.js","mtime":1645990066541},{"path":"/Users/anne-sophieroy/Downloads/Mainsail/mainsail-maintenance/node_modules/@vue/cli-service/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":1645990070825},{"path":"/Users/anne-sophieroy/Downloads/Mainsail/mainsail-maintenance/node_modules/postcss-loader/src/index.js","mtime":1645990067674},{"path":"/Users/anne-sophieroy/Downloads/Mainsail/mainsail-maintenance/node_modules/cache-loader/dist/cjs.js","mtime":1645990064605},{"path":"/Users/anne-sophieroy/Downloads/Mainsail/mainsail-maintenance/node_modules/@vue/cli-service/node_modules/vue-loader/lib/index.js","mtime":1645990069130}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ci53ZWJjYW1GcHNPdXRwdXQgewogICAgZGlzcGxheTogaW5saW5lLWJsb2NrOwogICAgcG9zaXRpb246YWJzb2x1dGU7CiAgICBib3R0b206IDZweDsKICAgIHJpZ2h0OiAwOwogICAgYmFja2dyb3VuZDogcmdiYSgwLDAsMCwwLjgpOwogICAgcGFkZGluZzogM3B4IDEwcHg7CiAgICBib3JkZXItdG9wLWxlZnQtcmFkaXVzOiA1cHg7Cn0K"},{"version":3,"sources":["MjpegstreamerAdaptive.vue"],"names":[],"mappings":";AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"MjpegstreamerAdaptive.vue","sourceRoot":"src/components/webcams","sourcesContent":["<style scoped>\n    .webcamFpsOutput {\n        display: inline-block;\n        position:absolute;\n        bottom: 6px;\n        right: 0;\n        background: rgba(0,0,0,0.8);\n        padding: 3px 10px;\n        border-top-left-radius: 5px;\n    }\n</style>\n\n<template>\n    <div v-observe-visibility=\"visibilityChanged\" style=\"position: relative;\">\n        <div class=\"text-center py-5\" v-if=\"!isLoaded\">\n            <v-progress-circular indeterminate color=\"primary\"></v-progress-circular>\n        </div>\n        <canvas ref=\"mjpegstreamerAdaptive\" width=\"600\" height=\"400\" :style=\"webcamStyle\" :class=\"'webcamImage '+(isLoaded ? '' : 'hiddenWebcam')\"></canvas>\n        <span class=\"webcamFpsOutput\" v-if=\"isLoaded && showFps\">{{ $t('Panels.WebcamPanel.FPS')}}: {{ fpsOutput }}</span>\n    </div>\n</template>\n\n<script lang=\"ts\">\nimport Component from 'vue-class-component'\nimport {Mixins, Prop} from 'vue-property-decorator'\nimport BaseMixin from '@/components/mixins/base'\n\n@Component\nexport default class MjpegstreamerAdaptive extends Mixins(BaseMixin) {\n    private refresh = Math.ceil(Math.random() * Math.pow(10, 12))\n    private isVisible = true\n    private isLoaded = true\n    private timer: number | undefined = undefined\n\n    private request_start_time = performance.now()\n    private start_time = performance.now()\n    private time = 0\n    private request_time = 0\n    private time_smoothing = 0.6\n    private request_time_smoothing = 0.1\n    private currentFPS = 0\n\n    $refs!: {\n        mjpegstreamerAdaptive: any\n    }\n\n    @Prop({ required: true }) camSettings: any\n    @Prop() printerUrl: string | undefined\n    @Prop({ default: true }) showFps!: boolean\n\n    get webcamStyle() {\n        let transforms = ''\n        if ('flipX' in this.camSettings && this.camSettings.flipX) transforms += ' scaleX(-1)'\n        if ('flipX' in this.camSettings && this.camSettings.flipY) transforms += ' scaleY(-1)'\n        if (transforms.trimLeft().length) return { transform: transforms.trimLeft() }\n\n        return ''\n    }\n\n    get fpsOutput() {\n        return (this.currentFPS < 10) ? '0'+this.currentFPS.toString() : this.currentFPS\n    }\n\n    visibilityChanged(isVisible: boolean) {\n        this.isVisible = isVisible\n        if (isVisible) this.refreshFrame()\n        else {\n            clearTimeout(this.timer)\n            this.timer = undefined\n        }\n    }\n\n    refreshFrame() {\n        if (this.isVisible) {\n            this.refresh = new Date().getTime()\n            this.setFrame()\n        }\n    }\n\n    onLoad() {\n        this.isLoaded = true\n\n        const targetFps = this.camSettings.targetFps || 10\n        const end_time = performance.now()\n        const current_time = end_time - this.start_time\n        this.time = (this.time * this.time_smoothing) + (current_time * (1.0 - this.time_smoothing))\n        this.start_time = end_time\n\n        const target_time = 1000 / targetFps\n\n        const current_request_time = performance.now() - this.request_start_time\n        this.request_time = (this.request_time * this.request_time_smoothing) + (current_request_time * (1.0 - this.request_time_smoothing))\n        const timeout = Math.max(0, target_time - this.request_time)\n\n        this.$nextTick(() => {\n            this.timer = setTimeout(this.refreshFrame, timeout)\n        })\n    }\n\n    async setFrame() {\n        const baseUrl = this.camSettings.urlSnapshot\n        const url = new URL(baseUrl, this.printerUrl === undefined ? this.hostUrl.toString() : this.printerUrl)\n\n        url.searchParams.append('bypassCache', this.refresh.toString())\n\n        this.request_start_time = performance.now()\n        this.currentFPS = (this.time > 0) ? Math.round(1000 / this.time) : 0\n\n        let canvas = this.$refs.mjpegstreamerAdaptive\n        if (canvas) {\n            const ctx = canvas.getContext('2d')\n            const frame: any = await this.loadImage(url.toString())\n\n            canvas.width = canvas.clientWidth\n            canvas.height = canvas.clientWidth * (frame.height / frame.width)\n\n            ctx?.drawImage(frame,\n                0, 0, frame.width, frame.height,\n                0, 0, canvas.width, canvas.height)\n            this.isLoaded = true\n        }\n\n        this.$nextTick(() => {\n            this.onLoad()\n        })\n    }\n\n    loadImage(url: string) {\n        return new Promise(r => {\n            let image = new Image()\n            image.onload = (() => r(image))\n            image.onerror = (() => setTimeout(this.refreshFrame, 1000))\n            image.src = url\n        })\n    }\n}\n</script>"]}]}